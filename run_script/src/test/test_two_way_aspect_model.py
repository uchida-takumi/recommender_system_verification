#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import unittest
from .. import two_way_aspect_model

import numpy as np

"""プログラミング用
from src import two_way_aspect_model
import numpy as np
"""

class test_two_way_aspect_model(unittest.TestCase):
    
    def setUp(self):
        pass
    
    def test__two_way_aspect_model(self):
        """ 
        the test data is generated by obvious tendency.
        """
        # person-actorsの視聴回数行列で、person3,4はactor3をよく見る傾向がある。
        Npa = np.array([
                [3,3,3,0],
                [1,1,1,1],
                [1,2,3,0],
                [0,0,1,3],
                [0,1,0,2],                
                ])
        # 推定対象のmovie-actorsの出演行列を設定。
        # actor3が出演しているmovie1がperson3,4で高確率であれば、学習は正常と言える。
        Nma = np.array([
                [1,1,1,0],
                [0,0,0,1],
                ])
        
        Z = 2
        twam = two_way_aspect_model._two_way_aspect_model(Z)
        twam.fit(Npa)
        Ppm = twam.predict(Nma)
        
        # --- Assertion ---
        print(Ppm)
        ## person0,1,2 は movie0 が良い傾向にある            
        for i in [0,1,2]:
            self.assertTrue(Ppm[i, 0] > Ppm[i, 1])
        ## person3,4 は movie1 が良い傾向にある
        for i in [3,4]:
            self.assertTrue(Ppm[i, 0] < Ppm[i, 1])
        ## person0 - movie0 の確率が最大になっている必要がある
        self.assertTrue(Ppm[0, 0], Ppm.max())


    def test_two_way_aspect_model(self):
        """ 
        the test data is generated by obvious tendency.
        """
        # set Input
        Z = 2
        item_attributes = {'i0':[1,1,0,0], 'i1':[0,0,1,1], 'i2':[0,1,1,1]}
        user_ids = ['u0','u0','u0','u0','u0','u0','u1','u2']
        item_ids = ['i0','i0','i0','i0','i1','i2','i1','i2']
        values   = [   5,   5,   5,   5,   1,   3,   2,   5]

        # learn
        twam = two_way_aspect_model.two_way_aspect_model(Z, item_attributes)        
        twam.fit(user_ids, item_ids, values, postive_threshold=5)
        
        # two_way_aspect_model は推定の際は item の属性変数のみを用いるため、use_idで値は変化しない。
        same_items = twam.predict(['u0','u1','u2','u999'], ['i0','i0','i0','i0'])
        for predicted in same_items:
            self.assertEqual(predicted, same_items[0])
            
        # positive_threshold=5 なので values が５以上の tuple だけで学習し、発生確率を推定する。
        # この時、説明変数として item_attributes しか利用しません。
        # そのため上記の例では、i2がvalues>=5を獲得した属性持ちなので、これが推定最大値になるはずです。
        predicted = twam.predict(['u','u','u','u'],
                                 ['i0','i1','i2','i999'])
        self.assertEqual(predicted[2], max(predicted))
    

    def tearDown(self):
        pass

if __name__ == '__main__':
    unittest.main()


